Specific software architecture doesn't really work lol.

Do not look too far ahead.

Explore and Lock.

Just explore and write code without thinking about the encompassing structure too much.

---

Software architecture is not really architecture as a blueprint, as this is basically what programming itself is. If "architecture" is supposed to produce a blueprint that is sufficient enough to explain how the program works, then this is actually the full code of the program itself.

Software architecture, in practice, is separation of code.

The purposes of separation:

- mental clarity, keeping things separate so you don't have to consider them at once
- code reuse
- division of labor

---

Not to have anyone step above you, but to be just, do not step on anyone then. Fair trade.

---

"It actually looks like im better at math on the screen than I actually am. Probably because I am covering things that I know really well. When I'm actually working out new math stuff it's atrocious. It's a disaster zone all the time."

- Casey Muratori

---

- Reusable Game Modules
- Build Systems, Not Games
- Simulation vs View Separation

Learn fundaments well, use whatever tools to get the job done.

Learn from Thronefall

---

sage
sensei
kenna
kennari
namsmadur

sage-madur

d--- bagda

b------- d---

---

Ventsi: "Most important for programming is simplicity"

---

// ---------------
// -- PARTICLES --
// ---------------

The laws of nature are just the habits of the insignificant.

The giants of this world are not intrinsically large, only persistently small.
They are the stubborn repetition of the minimal until it becomes monumental.

// ---------------
// -- RECURSION --
// ---------------

The Paradox of Foundations

Mathematics, language, logic—all rest upon recursive structures. A definition depends on other definitions, which in turn depend on the first. A function calls itself, nesting deeper until it reaches a base case that was always implicit. This reveals a profound truth: that all systems, no matter how formal, ultimately rest upon self-reference. There is no final, unshakable ground—only the certainty that any foundation we name will eventually point back to itself.

Know that as is above, so is below.

If the universe is computational, as some speculate, then its program is written in recursion.

The loop folds back upon itself, feeding its own existence.

The output becomes its own input.

The act of becoming alters the conditions of becoming.

What bends a branch also curves a mountain.

And so it unfolds. Again. Again. Again...
